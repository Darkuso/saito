// no 'use strick' as we need to delete from hashmaps
const saito    = require('../saito');
const Big      = require('big.js');
var os         = require('os');

/**
 * Cluster Contructor
 * @param {*} app
 */
function Cluster(app) {

  if (!(this instanceof Cluster)) { return new Cluster(app); }

  this.app = app;

  this.enable_clustering  = 1;
  this.number_of_clusters = 3;
  this.child_forks        = [];
  this.children_validated = 0;
  this.fork_counter       = 0;

  this.validating_txs     = 0;
  this.validating_timer   = 20;
  this.tx_validators_ok   = 0;
  this.tx_validators_max  = 0;

  this.tx_to_validate     = 0;
  this.tx_validated       = 0;

  return this;

}
module.exports = Cluster;






Cluster.prototype.sendPing = function sendPing() {
  for (let f = 0; f < this.child_forks.length; f++) {
    this.child_forks[f].send({ ping: 1 });
  }
}


Cluster.prototype.validateTransactions = async function validateTransactions(blk) {

  if (this.enable_clustering == 0) {
    for (let i = 0; i < blk.transactions.length; i++) {
      if (!blk.transactions[i].clusterValidate(blk.app)) {
        console.log(`Block invalid: contains invalid transaction: ${i}`);
        this.app.logger.logError("Block invalid: contains invalid transaction: " + i, {message:"",err:""});
        return 0;
      }
    }
    return 1;
  }

  var cluster_self = this;

  this.validating_txs    = 1;
  this.tx_to_validate    = this.child_forks.length;
  this.tx_validated      = 0;

  let blks      = [this.tx_to_validate];
  let blksjson  = [this.tx_to_validate];

  for (let i = 0; i < this.tx_to_validate; i++) {
    blks[i]     = new saito.block(this.app);
  }

  for (let t = 0, f = 0, idx = 0; t < blk.block.txsjson.length; t++, f++) {
    if (f == this.tx_to_validate) { idx++; f = 0; }
    blks[f].block.txsjson[idx] = blk.block.txsjson[t];
  }

console.log("pre stringify: " + new Date().getTime());
  for (let i = 0; i < this.tx_to_validate; i++) {
    blksjson[i] = JSON.stringify(blks[i].block);
  }
console.log("pst stringify: " + new Date().getTime());

  
//  let blkjson = JSON.stringify(blk.block);

//console.log("THIS NUM CHILDREN: " + this.tx_to_validate);

  for (let f = 0; f < this.child_forks.length; f++) {
    this.tx_validators_max++;
console.log("send to child " + f);
    this.child_forks[f].send({ validateTransactions: 1 , blk : blksjson[f] , child : f , max_children : this.child_forks.length });
  }

  var promise = new Promise(function(resolve, reject) {
    setTimeout(() => {
      cluster_self.validateTransactionsCount(resolve, 0);
    }, cluster_self.validating_timer);
  });

  return promise;

}
Cluster.prototype.validateTransactionsCount = function validateTransactionsCount(resolve, num) {

  var cluster_self = this;

  if (this.validating_txs == -1) {
console.log("resolving false...");
    resolve(0);
    return;
  }

  if (this.tx_to_validate == this.tx_validated) {
console.log("resolving true: " + this.tx_to_validate + " -- " + this.tx_validated);
    resolve(1);
  } else {
    setTimeout(() => { cluster_self.validateTransactionsCount(resolve, num+1); }, cluster_self.validating_timer);
  }

}



////////////////
// Initialize //
////////////////
Cluster.prototype.initialize = async function initialize() {

  var cluster_self = this;

  if (this.app.BROWSER == 1 || this.app.SPVMODE == 1) {
    this.enable_clustering = 0;
    return;
  }

  if (this.enable_clustering == 0) { return; }

  var number_of_forks = require('os').cpus().length-1;
  if (this.number_of_clusters <= number_of_forks) {
    number_of_forks = this.number_of_clusters;
  }
  if (number_of_forks <= 0) { number_of_forks = 1; }

  const { fork } = require('child_process');

  for (var f = 0; f < number_of_forks; f++) {

    var forked = fork('child.js');
    forked.on('message', (msg) => {

      if (msg.ping != undefined) {
        console.log(" ... pinged by child");
      }

      if (msg.validateTransactions != undefined) {
        if (msg.validateTransactions == 1) {	  
	  console.log("OK from: " + cluster_self.tx_validated);
	  cluster_self.tx_validated++;
        }
        if (msg.validateTransactions == 0) {	  
	  console.log("NOT OK from: " + cluster_self.tx_validated);
	  cluster_self.validating_txs = -1;
        }
      }

    });
    this.child_forks.push(forked);
  }

}


